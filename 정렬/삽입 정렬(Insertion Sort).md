# 삽입 정렬(Insertion Sort)

- 선택 정렬과 조금 유사하지만 좀 더 효율적인 정렬 알고리즘 입니다.
- 2번째 원소부터 시작하여 그 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 지정한 후에 원소를 모두 뒤로 옮기고 지정된 자리에 자료를 삽입하는 정렬 알고리즘 입니다.
- 시간 복잡도
  - 최선의 경우 (모두 정렬되어 있는 경우) O(N)이라는 효율을 가지고 있습니다. 한번씩 밖에 비교를 하지 않기 때문입니다. 이미 정렬되어 있는 배열에 자료를 하니씩 삽입/제거하는 경우에도 현실적으로 최고의 정렬 알고리즘이 됩니다. 이유는 탐색을 제외한 오버헤드가 매우 적기 때문입니다.
  -  평균과 최악의 경우 O(n^2)의 시간 복잡도를 가집니다.
- 공간 복잡도 : O(n), 주어진 배열 안에서 교환을 통해 정렬이 수행됩니다.
- 장점
  - 알고리즘이 단순합니다.
  - 대부분의 원소가 정렬되어 있으면 매우 효율적일 수 있습니다.
  - 다른 메모리 공간이 필요하지 않는 제자리 정렬입니다.
  - 안정 정렬 입니다.
  - 선택정렬이나 버블정렬에 비해 상대적으로 빠릅니다.
- 단점
  - 평균과 최악의 시간복잡도가 O(n^2)으로 비효율적입니다.
  - Bubble Sort와 Selection Sort와 마찬가지로, 배열의 길이가 길어질수록 비효율적이다.
- 선택정렬과 차이점
  - 선택 정렬은 k+1 번째 요소를 찾기 위해 나머지 모든 요소들을 탐색하지만 삽입 정렬은 k+1번째 요소를 배치하는 데 필요한 만큼의 요소만 탐색하기 때문에 훨신 효율적입니다.



- 소스코드

```java
class Study {
	public static void main(String[] args) {
		int[] arr = {5, 10, 16, 1, 300, 34, 60};

		for (int i = 1; i < arr.length; i++) {
			int b = arr[i];
			int index = i;
			for (int j = i-1; j >= 0; j--) {
				if(arr[j]<b) break;
				arr[j+1] = arr[j];
				index = j;
			}
			arr[index] = b;
		}
		
		System.out.println(Arrays.toString(arr));

	}
}
```

